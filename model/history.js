fx.ns("fx", class History extends fx.EventDispatcher{

    constructor(model, nbActionsStored)
    {
        super();

        if (!model instanceof fx.Model)
        {
            fx.throwError("Model constructor must be an instance of Model or ModelArray")
            return;
        }

        this._model = model;

        this._actions = [];
        this._position = -1;
        this._timestampBetweenActions = 1000;
        this._timestampActionsInGroup = 250;
        this._maxActionsStored = (nbActionsStored !== undefined) ? nbActionsStored : 10; 

        this.on("updated", this._onDataUpdated, this._model);

        this._startTimeStamp = new Date();

        // so far, no need to track events
        //this.on("event", this._onDataEvent, this._model);
    
    }


    get model()
    {
        return this._model;
    }

    get timestamp()
    {
        return this._timestampBetweenActions;
    }

    get timestampActionsInGroup()
    {
        return this._timestampActionsInGroup;
    }


    get position()
    {
        return this._position;
    }

    set position(val)
    {
        this._position = val;
        this.trigger("updated");
    }

    get actions()
    {
        return this._actions;
    }

    get canUndo()
    {
        return this._actions.length > 0 && this._position >= 0;
    }

    get canRedo()
    {
        return this._actions.length > 0 && this._position < this._actions.length - 1;
    }

    get currentAction()
    {
        return this._actions[this._position];
    }

    clear()
    {
        this._actions = [];
        this.position = -1;
    }

    undo()
    {
        if (!this.canUndo) return;

        this._lastTimeStamp = new Date();

        for (let i = this.currentAction.actions.length-1; i >=0; i--)
            this.currentAction.actions[i] && this.currentAction.actions[i].undo();
    
        this.position = this.position - 1;

        
    }

    redo()
    {
        if (!this.canRedo) return;

        this._lastTimeStamp = new Date();
        
        this.position = this.position + 1;
        
        for (let i = 0; i < this.currentAction.actions.length; i++)
            this.currentAction.actions[i] && this.currentAction.actions[i].redo();

        
    }

    // raisonner en groupe d'actions
    _onDataUpdated(e)
    {
        // we don't count any action generated at start
        if ((new Date()) - this._startTimeStamp < 2000)
            return;

        let action = e.action;

        if (!action || action.history)
            return;

        // we don't count any action generated by last undo/redo
        if ((new Date()) - this._lastTimeStamp < 100)
            return;

        if (!this.valid(action))
            return;

        // means we undone some updates, and started to work
        // so let remove next actions
        this._actions.splice(this._position + 1);

        let newAction = action.clone();
   
        newAction.history = true;
        
        // need to check last newAction, and see if it's on same component
        // and check if timestamp if very close
        // and then only merge newAction with this one
        //let lastAction = this._actions.last();
        let lastGroup = this._actions.last();

        let lastAction = lastGroup ? lastGroup.actions.last() : null;
    
        if (this.needMerge(lastAction, newAction, lastGroup))
        {
            lastAction.data = Object.assign({}, lastAction.data, newAction.data);
            lastAction.previous = Object.assign({}, newAction.previous, lastAction.previous);
            lastAction.properties = lastAction.properties.concat(newAction.properties).unique()
            lastAction.timestamp = newAction.timestamp;
        }
        else
        if (lastGroup && lastAction &&
                (   ( (newAction.timestamp - lastAction.timestamp) < this.timestampActionsInGroup) 
                /*|| 
                    (lastGroup.actions.last().model == (newAction.data || newAction.model) && (newAction.type == "delete" || newAction.type == "removeItem")) */) 
                 )
            lastGroup.actions.push( newAction );
        else
        {
            lastGroup = { actions : [newAction] };
            this._actions.push( lastGroup ); // new group

            if (this._maxActionsStored && this._actions.length > this._maxActionsStored)
                this._actions.shift();
        }
    
        this.position = this._actions.length - 1;

        //return lastGroup;
    }

    needMerge(lastAction, action, lastGroup)
    {
        return lastAction && action.type == "update" && lastAction.type == "update" && lastAction.model == action.model && (action.timestamp - lastAction.timestamp) < this.timestamp;
    }

    valid(action)
    {
        if (action.type == "update" && Utils.ObjectEquals(action.previous, action.data))
            return false;

        return action.type != "init";
    }

    

});

